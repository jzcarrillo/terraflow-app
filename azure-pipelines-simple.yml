trigger:
  branches:
    include:
      - main

pool:
  name: 'Default'

variables:
  imageTag: '$(Build.BuildId)'
  registry: 'localhost:5001'

stages:
  # Stage 1: Build and Unit Test
  - stage: Build
    displayName: 'Build & Unit Test'
    jobs:
      - job: BuildAndTest
        displayName: 'NPM Build & Jest Tests'
        steps:
          - script: |
              echo "Installing dependencies..."
              npm install --silent
              
              # Install frontend dependencies
              cd frontend
              npm install --silent
              cd ..
              
              # Build all services
              SERVICES=("backend-landregistry" "api-gateway" "backend-documents" "backend-users" "backend-payments" "backend-blockchain" "frontend")
              for service in "${SERVICES[@]}"; do
                if [ -f "./$service/package.json" ]; then
                  echo "Building $service..."
                  cd "./$service"
                  npm install --silent
                  npm run build 2>/dev/null || echo "No build script"
                  cd ..
                fi
              done
            displayName: 'Build Services'

          - script: |
              echo "Running Jest unit tests with coverage..."
              npm test -- --coverage
            displayName: 'Run Jest Tests'

          - script: |
              echo "Deploying to Local Dev for E2E testing..."
              
              # Deploy to local dev namespace
              helm upgrade terraflow ./helm --install --timeout=10m \
                --namespace=terraflow-app --create-namespace
              
              # Wait for postgres pods first
              kubectl wait --for=condition=ready pod -l app=postgres-landregistry --timeout=120s --namespace=terraflow-app || true
              kubectl wait --for=condition=ready pod -l app=postgres-documents --timeout=120s --namespace=terraflow-app || true
              kubectl wait --for=condition=ready pod -l app=postgres-users --timeout=120s --namespace=terraflow-app || true
              kubectl wait --for=condition=ready pod -l app=postgres-payments --timeout=120s --namespace=terraflow-app || true
              
              # Create local dev databases (no suffix)
              echo "üîß Creating local dev databases..."
              ./scripts/create-dev-databases.sh || echo "Database creation failed, continuing..."
              
              # Wait for backend pods
              kubectl wait --for=condition=ready pod -l app=backend-landregistry --timeout=120s --namespace=terraflow-app
              kubectl wait --for=condition=ready pod -l app=api-gateway --timeout=120s --namespace=terraflow-app
              
              # API Gateway is now NodePort 30081, no port-forward needed
              echo "API Gateway accessible at http://localhost:30081"
              
              echo "‚úÖ Local dev deployed"
            displayName: 'Deploy to Local Dev'

          - script: |
              echo "Starting frontend on localhost:4005..."
              cd frontend
              npm install --silent
              npm run dev &
              FRONTEND_PID=$!
              
              # Wait for frontend
              sleep 10
              
              echo "‚úÖ Frontend running on http://localhost:4005"
            displayName: 'Start Frontend'

          - script: |
              echo "Running Playwright E2E tests on Local Dev..."
              echo "Target URL: http://localhost:4005"
              
              npm run automate:dev
              
              echo "‚úÖ Local Dev E2E tests passed"
            displayName: 'Run E2E Tests on Local Dev'

          - script: |
              echo "Cleaning up ALL old images from registry..."
              
              # Delete all images from registry
              docker exec registry sh -c "rm -rf /var/lib/registry/docker/registry/v2/repositories/terraflow/*" 2>/dev/null || true
              
              # Run garbage collection
              docker exec registry registry garbage-collect /etc/docker/registry/config.yml 2>/dev/null || true
              
              echo "‚úÖ Registry cleaned (all old images deleted)"
            displayName: 'Clean Registry (Delete All)'

          - script: |
              echo "Building and pushing Docker images to registry..."
              echo "Image tag: $(imageTag)"
              echo "Note: Single universal image for all environments (runtime config)"
              
              # Build and push all services
              docker build -t $(registry)/terraflow/backend-landregistry:$(imageTag) ./backend-landregistry
              docker push $(registry)/terraflow/backend-landregistry:$(imageTag)
              
              docker build -t $(registry)/terraflow/api-gateway:$(imageTag) ./api-gateway
              docker push $(registry)/terraflow/api-gateway:$(imageTag)
              
              docker build -t $(registry)/terraflow/backend-documents:$(imageTag) ./backend-documents
              docker push $(registry)/terraflow/backend-documents:$(imageTag)
              
              docker build -t $(registry)/terraflow/backend-users:$(imageTag) ./backend-users
              docker push $(registry)/terraflow/backend-users:$(imageTag)
              
              docker build -t $(registry)/terraflow/backend-payments:$(imageTag) ./backend-payments
              docker push $(registry)/terraflow/backend-payments:$(imageTag)
              
              docker build -t $(registry)/terraflow/backend-blockchain:$(imageTag) ./backend-blockchain
              docker push $(registry)/terraflow/backend-blockchain:$(imageTag)
              
              # Frontend: Universal image (no build args, runtime config via /api/config)
              docker build -t $(registry)/terraflow/frontend:$(imageTag) ./frontend
              docker push $(registry)/terraflow/frontend:$(imageTag)
              
              echo "‚úÖ All images pushed to registry with tag: $(imageTag)"
            displayName: 'Build & Push Docker Images'

          - script: |
              echo "üóëÔ∏è  Cleaning up Local Dev environment..."
              
              # Delete local dev namespace to free resources
              helm uninstall terraflow -n terraflow-app || true
              kubectl delete namespace terraflow-app --timeout=60s || true
              
              # Kill port-forward processes
              pkill -f "port-forward.*terraflow-app" || true
              
              # Kill frontend process
              pkill -f "npm run dev" || true
              
              echo "‚úÖ Local Dev environment cleaned up"
            displayName: 'Cleanup Local Dev Environment'

  # Stage 2: Deploy to QA + E2E Tests
  - stage: DeployQA
    displayName: 'QA Environment'
    dependsOn: Build
    condition: succeeded()
    jobs:
      - deployment: QA
        displayName: 'Deploy to QA'
        environment: 'terraflow-qa'
        strategy:
          runOnce:
            deploy:
              steps:
                - script: |
                    echo "Deploying to QA environment with image tag: $(imageTag)"
                    
                    # Delete QA namespace if exists (fresh start)
                    echo "üóëÔ∏è  Cleaning up old QA environment..."
                    helm uninstall terraflow-qa -n terraflow-qa || true
                    kubectl delete namespace terraflow-qa --timeout=60s || true
                    sleep 5
                    
                    echo "üì¶ Creating QA namespace..."
                    kubectl create namespace terraflow-qa || true
                    
                    # Deploy to K8s QA namespace using images from registry
                    helm upgrade terraflow-qa ./helm --install --timeout=10m \
                      --namespace=terraflow-qa --create-namespace \
                      --set image.tag=$(imageTag) \
                      --set image.repository=$(registry)/terraflow \
                      --values=./helm/values-qa.yaml
                    
                    if [ $? -ne 0 ]; then
                      echo "‚ùå Helm deployment failed!"
                      exit 1
                    fi
                    
                    # Wait for postgres pods first
                    kubectl wait --for=condition=ready pod -l app=postgres-landregistry --timeout=120s --namespace=terraflow-qa || true
                    kubectl wait --for=condition=ready pod -l app=postgres-documents --timeout=120s --namespace=terraflow-qa || true
                    kubectl wait --for=condition=ready pod -l app=postgres-users --timeout=120s --namespace=terraflow-qa || true
                    kubectl wait --for=condition=ready pod -l app=postgres-payments --timeout=120s --namespace=terraflow-qa || true
                    
                    # Create QA databases
                    echo "üîß Creating QA databases..."
                    ./scripts/create-qa-databases.sh || echo "Database creation failed, continuing..."
                    
                    # Wait for backend pods
                    kubectl wait --for=condition=ready pod -l app=backend-landregistry --timeout=120s --namespace=terraflow-qa
                    kubectl wait --for=condition=ready pod -l app=api-gateway --timeout=120s --namespace=terraflow-qa
                    kubectl wait --for=condition=ready pod -l app=frontend --timeout=120s --namespace=terraflow-qa
                    
                    echo "‚úÖ QA deployment successful"
                    echo "üåê QA Frontend: http://localhost:30082"
                    echo "üåê QA API Gateway: http://localhost:30092"
                  displayName: 'Deploy to QA'

                - script: |
                    echo "Running Playwright E2E tests on QA..."
                    echo "Target URL: http://localhost:30082"
                    
                    npm run automate:qa
                    
                    echo "‚úÖ QA E2E tests passed"
                  displayName: 'Run E2E Tests on QA'

  # Stage 3: Deploy to UAT + E2E Tests
  - stage: DeployUAT
    displayName: 'UAT Environment'
    dependsOn: DeployQA
    condition: succeeded()
    jobs:
      - deployment: UAT
        displayName: 'Deploy to UAT'
        environment: 'terraflow-uat'
        strategy:
          runOnce:
            deploy:
              steps:
                - script: |
                    echo "Deploying to UAT environment with image tag: $(imageTag)"
                    
                    # Delete QA namespace to free resources
                    echo "üóëÔ∏è  Cleaning up QA environment..."
                    helm uninstall terraflow-qa -n terraflow-qa || true
                    kubectl delete namespace terraflow-qa --timeout=60s || true
                    sleep 5
                    
                    # Delete UAT namespace if exists (fresh start)
                    echo "üóëÔ∏è  Cleaning up old UAT environment..."
                    helm uninstall terraflow-uat -n terraflow-uat || true
                    kubectl delete namespace terraflow-uat --timeout=60s || true
                    sleep 5
                    
                    echo "üì¶ Creating UAT namespace..."
                    kubectl create namespace terraflow-uat || true
                    
                    # Deploy to K8s UAT namespace using images from registry
                    helm upgrade terraflow-uat ./helm --install --timeout=10m \
                      --namespace=terraflow-uat --create-namespace \
                      --set image.tag=$(imageTag) \
                      --set image.repository=$(registry)/terraflow \
                      --values=./helm/values-uat.yaml
                    
                    # Wait for postgres pods first
                    kubectl wait --for=condition=ready pod -l app=postgres-landregistry --timeout=120s --namespace=terraflow-uat || true
                    kubectl wait --for=condition=ready pod -l app=postgres-documents --timeout=120s --namespace=terraflow-uat || true
                    kubectl wait --for=condition=ready pod -l app=postgres-users --timeout=120s --namespace=terraflow-uat || true
                    kubectl wait --for=condition=ready pod -l app=postgres-payments --timeout=120s --namespace=terraflow-uat || true
                    
                    # Create UAT databases
                    echo "üîß Creating UAT databases..."
                    ./scripts/create-uat-databases.sh || echo "Database creation failed, continuing..."
                    
                    # Wait for backend pods
                    kubectl wait --for=condition=ready pod -l app=backend-landregistry --timeout=120s --namespace=terraflow-uat
                    kubectl wait --for=condition=ready pod -l app=api-gateway --timeout=120s --namespace=terraflow-uat
                    kubectl wait --for=condition=ready pod -l app=frontend --timeout=120s --namespace=terraflow-uat
                    
                    echo "‚úÖ UAT deployment successful"
                    echo "üåê UAT Frontend: http://localhost:30083"
                    echo "üåê UAT API Gateway: http://localhost:30093"
                  displayName: 'Deploy to UAT'

                - script: |
                    echo "Running Playwright E2E tests on UAT..."
                    echo "Target URL: http://localhost:30083"
                    
                    npm run automate:uat
                    
                    echo "‚úÖ UAT E2E tests passed"
                  displayName: 'Run E2E Tests on UAT'

  # Stage 4: Deploy to PROD (Manual Approval Required)
  - stage: DeployProd
    displayName: 'PROD Environment'
    dependsOn: DeployUAT
    condition: succeeded()
    jobs:
      - deployment: Prod
        displayName: 'Deploy to PROD'
        environment: 'terraflow-prod'
        strategy:
          runOnce:
            deploy:
              steps:
                - script: |
                    echo "Deploying to PROD environment with image tag: $(imageTag)"
                    
                    # Delete UAT namespace to free resources
                    echo "üóëÔ∏è  Cleaning up UAT environment..."
                    helm uninstall terraflow-uat -n terraflow-uat || true
                    kubectl delete namespace terraflow-uat --timeout=60s || true
                    sleep 5
                    
                    # Delete PROD namespace if exists (fresh start)
                    echo "üóëÔ∏è  Cleaning up old PROD environment..."
                    helm uninstall terraflow-prod -n terraflow-prod || true
                    kubectl delete namespace terraflow-prod --timeout=60s || true
                    sleep 5
                    
                    echo "üì¶ Creating PROD namespace..."
                    kubectl create namespace terraflow-prod || true
                    
                    # Deploy to K8s PROD namespace using images from registry
                    helm upgrade terraflow-prod ./helm --install --timeout=10m \
                      --namespace=terraflow-prod --create-namespace \
                      --set image.tag=$(imageTag) \
                      --set image.repository=$(registry)/terraflow \
                      --values=./helm/values-prod.yaml
                    
                    # Wait for postgres pods first
                    kubectl wait --for=condition=ready pod -l app=postgres-landregistry --timeout=120s --namespace=terraflow-prod || true
                    kubectl wait --for=condition=ready pod -l app=postgres-documents --timeout=120s --namespace=terraflow-prod || true
                    kubectl wait --for=condition=ready pod -l app=postgres-users --timeout=120s --namespace=terraflow-prod || true
                    kubectl wait --for=condition=ready pod -l app=postgres-payments --timeout=120s --namespace=terraflow-prod || true
                    
                    # Create PROD databases (with _prod suffix)
                    echo "üîß Creating PROD databases..."
                    ./scripts/create-prod-databases.sh || echo "Database creation failed, continuing..."
                    
                    # Wait for backend pods
                    kubectl wait --for=condition=ready pod -l app=backend-landregistry --timeout=120s --namespace=terraflow-prod
                    kubectl wait --for=condition=ready pod -l app=api-gateway --timeout=120s --namespace=terraflow-prod
                    kubectl wait --for=condition=ready pod -l app=frontend --timeout=120s --namespace=terraflow-prod
                    
                    echo "üöÄ PROD deployment successful!"
                    echo "üåê PROD Frontend: http://localhost:30081"
                    echo "üåê PROD API Gateway: http://localhost:30091"
                    echo "üì¶ Deployed artifact version: $(imageTag)"
                  displayName: 'Deploy to PROD'
